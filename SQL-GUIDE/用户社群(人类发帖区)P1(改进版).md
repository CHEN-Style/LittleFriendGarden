# 用户社群（人类发帖区）P2（改进版）

## 0. 准备

```sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

```

统一更新时间触发器（若已存在可复用）：

```sql
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END
$$ LANGUAGE plpgsql;

```

---

## 1) 话题体系（字典 + 关联）

```sql
-- 1.1 话题字典
CREATE TABLE IF NOT EXISTS topics (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug          CITEXT UNIQUE,          -- URL 友好的唯一标识（可空；有则唯一）
  name          CITEXT NOT NULL,        -- 展示名
  description   TEXT,
  is_official   BOOLEAN NOT NULL DEFAULT FALSE,  -- 官方话题
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at    TIMESTAMPTZ
);

CREATE TRIGGER trg_topics_updated_at
BEFORE UPDATE ON topics
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- 1.2 话题与帖子多对多
CREATE TABLE IF NOT EXISTS post_topics (
  post_id   UUID NOT NULL,
  topic_id  UUID NOT NULL REFERENCES topics(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (post_id, topic_id)
);

```

---

## 2) 帖子与评论

```sql
-- 2.1 帖子
CREATE TABLE IF NOT EXISTS posts (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  author_user_id   UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title            TEXT,                         -- 可选
  text             TEXT,                         -- 正文（纯文本或 markdown）
  topics           TEXT[] NOT NULL DEFAULT ARRAY[]::TEXT[],  -- 自由标签，后续沉淀到 topics
  visibility       TEXT NOT NULL DEFAULT 'public',            -- 'public'|'friends'|'private'
  allow_comments   BOOLEAN NOT NULL DEFAULT TRUE,
  comment_count    INTEGER NOT NULL DEFAULT 0,   -- 计数反范式
  like_count       INTEGER NOT NULL DEFAULT 0,   -- 计数反范式
  meta             JSONB NOT NULL DEFAULT '{}'::jsonb,  -- 端上渲染/AB 实验等
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at       TIMESTAMPTZ,
  CHECK (visibility IN ('public','friends','private'))
);

CREATE TRIGGER trg_posts_updated_at
BEFORE UPDATE ON posts
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- 全文检索列（simple 解析，亦可改 'zh' 或自定义字典）
ALTER TABLE posts
  ADD COLUMN IF NOT EXISTS tsv tsvector
  GENERATED ALWAYS AS (to_tsvector('simple', coalesce(title,'') || ' ' || coalesce(text,''))) STORED;

CREATE INDEX IF NOT EXISTS idx_posts_tsv ON posts USING GIN (tsv);
CREATE INDEX IF NOT EXISTS idx_posts_author_time_alive
  ON posts (author_user_id, created_at DESC) WHERE deleted_at IS NULL;

-- 2.2 评论（支持楼中楼）
CREATE TABLE IF NOT EXISTS comments (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id          UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
  author_user_id   UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  parent_comment_id UUID REFERENCES comments(id) ON DELETE CASCADE, -- NULL 为一级评论
  text             TEXT NOT NULL,
  like_count       INTEGER NOT NULL DEFAULT 0,   -- 计数反范式
  meta             JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at       TIMESTAMPTZ
);

CREATE TRIGGER trg_comments_updated_at
BEFORE UPDATE ON comments
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- 常用索引
CREATE INDEX IF NOT EXISTS idx_comments_post_time_alive
  ON comments (post_id, created_at) WHERE deleted_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_comments_parent_time_alive
  ON comments (parent_comment_id, created_at) WHERE deleted_at IS NULL;

-- 评论全文检索
ALTER TABLE comments
  ADD COLUMN IF NOT EXISTS tsv tsvector
  GENERATED ALWAYS AS (to_tsvector('simple', coalesce(text,''))) STORED;

CREATE INDEX IF NOT EXISTS idx_comments_tsv ON comments USING GIN (tsv);

```

---

## 3) 点赞 / 反应（拆表去多态）

```sql
-- 3.1 帖子点赞（或反应类型扩展为 like/heart/haha...）
CREATE TABLE IF NOT EXISTS post_reactions (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id    UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
  user_id    UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  type       TEXT NOT NULL DEFAULT 'like',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (post_id, user_id, type)
);

-- 3.2 评论点赞
CREATE TABLE IF NOT EXISTS comment_reactions (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  comment_id UUID NOT NULL REFERENCES comments(id) ON DELETE CASCADE,
  user_id    UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  type       TEXT NOT NULL DEFAULT 'like',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (comment_id, user_id, type)
);

```

### 3.a 计数同步触发器

```sql
-- 帖子点赞计数
CREATE OR REPLACE FUNCTION inc_post_like_count() RETURNS TRIGGER AS $$
BEGIN
  UPDATE posts SET like_count = like_count + 1 WHERE id = NEW.post_id;
  RETURN NEW;
END$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION dec_post_like_count() RETURNS TRIGGER AS $$
BEGIN
  UPDATE posts SET like_count = GREATEST(like_count - 1, 0) WHERE id = OLD.post_id;
  RETURN OLD;
END$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_post_reactions_inc ON post_reactions;
CREATE TRIGGER trg_post_reactions_inc
AFTER INSERT ON post_reactions
FOR EACH ROW EXECUTE FUNCTION inc_post_like_count();

DROP TRIGGER IF EXISTS trg_post_reactions_dec ON post_reactions;
CREATE TRIGGER trg_post_reactions_dec
AFTER DELETE ON post_reactions
FOR EACH ROW EXECUTE FUNCTION dec_post_like_count();

-- 评论点赞计数
CREATE OR REPLACE FUNCTION inc_comment_like_count() RETURNS TRIGGER AS $$
BEGIN
  UPDATE comments SET like_count = like_count + 1 WHERE id = NEW.comment_id;
  RETURN NEW;
END$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION dec_comment_like_count() RETURNS TRIGGER AS $$
BEGIN
  UPDATE comments SET like_count = GREATEST(like_count - 1, 0) WHERE id = OLD.comment_id;
  RETURN OLD;
END$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_comment_reactions_inc ON comment_reactions;
CREATE TRIGGER trg_comment_reactions_inc
AFTER INSERT ON comment_reactions
FOR EACH ROW EXECUTE FUNCTION inc_comment_like_count();

DROP TRIGGER IF EXISTS trg_comment_reactions_dec ON comment_reactions;
CREATE TRIGGER trg_comment_reactions_dec
AFTER DELETE ON comment_reactions
FOR EACH ROW EXECUTE FUNCTION dec_comment_like_count();

```

### 3.b 评论计数触发器（在评论增删时同步帖子计数）

```sql
CREATE OR REPLACE FUNCTION inc_post_comment_count() RETURNS TRIGGER AS $$
BEGIN
  UPDATE posts SET comment_count = comment_count + 1 WHERE id = NEW.post_id;
  RETURN NEW;
END$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION dec_post_comment_count() RETURNS TRIGGER AS $$
BEGIN
  UPDATE posts SET comment_count = GREATEST(comment_count - 1, 0) WHERE id = OLD.post_id;
  RETURN OLD;
END$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_comments_inc_post_count ON comments;
CREATE TRIGGER trg_comments_inc_post_count
AFTER INSERT ON comments
FOR EACH ROW EXECUTE FUNCTION inc_post_comment_count();

DROP TRIGGER IF EXISTS trg_comments_dec_post_count ON comments;
CREATE TRIGGER trg_comments_dec_post_count
AFTER DELETE ON comments
FOR EACH ROW EXECUTE FUNCTION dec_post_comment_count();

```

---

## 4) 举报（拆表去多态）

```sql
-- 4.1 帖子举报
CREATE TABLE IF NOT EXISTS post_reports (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id       UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
  reporter_id   UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  reason_code   TEXT,                -- 'spam'|'abuse'|'copyright'|...
  reason_text   TEXT,
  status        TEXT NOT NULL DEFAULT 'pending',  -- 'pending'|'reviewing'|'resolved'|'rejected'
  resolution    TEXT,                -- 审核结论
  moderator_id  UUID REFERENCES users(id) ON DELETE SET NULL,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at    TIMESTAMPTZ,
  CHECK (status IN ('pending','reviewing','resolved','rejected'))
);

CREATE TRIGGER trg_post_reports_updated_at
BEFORE UPDATE ON post_reports
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- 4.2 评论举报
CREATE TABLE IF NOT EXISTS comment_reports (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  comment_id    UUID NOT NULL REFERENCES comments(id) ON DELETE CASCADE,
  reporter_id   UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  reason_code   TEXT,
  reason_text   TEXT,
  status        TEXT NOT NULL DEFAULT 'pending',
  resolution    TEXT,
  moderator_id  UUID REFERENCES users(id) ON DELETE SET NULL,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at    TIMESTAMPTZ,
  CHECK (status IN ('pending','reviewing','resolved','rejected'))
);

CREATE TRIGGER trg_comment_reports_updated_at
BEFORE UPDATE ON comment_reports
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

```

> 若你坚持单表方案，也可改为：在一张 reports 上同时保留 post_id/comment_id 双外键 + CHECK（二选一且仅一列非空），与我们在“宠物记录”中给的“弱绑定”思路一致。
> 

---

## 5) 附件（可选，指向素材池 `pet_assets`）

```sql
-- 开启前请确认 pet_assets(id) 已存在
CREATE TABLE IF NOT EXISTS post_attachments (
  post_id   UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
  asset_id  UUID NOT NULL REFERENCES pet_assets(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (post_id, asset_id)
);

CREATE TABLE IF NOT EXISTS comment_attachments (
  comment_id UUID NOT NULL REFERENCES comments(id) ON DELETE CASCADE,
  asset_id   UUID NOT NULL REFERENCES pet_assets(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (comment_id, asset_id)
);

```

> 如果你打算把“人类社群附件”与“宠物素材池”分开，也可以另外建 community_assets，本版为了复用统一的资源表，先对接 pet_assets。
> 

---

## 6) 视图与查询加速

```sql
-- 6.1 帖子公共视图（过滤软删除；可按需追加可见性判断）
CREATE OR REPLACE VIEW post_public_v AS
SELECT
  p.id,
  p.author_user_id,
  p.title,
  p.text,
  p.topics,
  p.visibility,
  p.allow_comments,
  p.comment_count,
  p.like_count,
  p.meta,
  p.created_at,
  p.updated_at
FROM posts p
WHERE p.deleted_at IS NULL;

-- 6.2 帖子 + 话题（便于详情页直接 JOIN）
CREATE OR REPLACE VIEW post_with_topics_v AS
SELECT
  p.id           AS post_id,
  p.title,
  p.text,
  p.topics       AS free_tags,
  p.visibility,
  p.comment_count,
  p.like_count,
  p.created_at,
  array_remove(array_agg(t.name) FILTER (WHERE t.id IS NOT NULL), NULL) AS official_topics
FROM posts p
LEFT JOIN post_topics pt ON pt.post_id = p.id
LEFT JOIN topics t ON t.id = pt.topic_id AND t.deleted_at IS NULL
WHERE p.deleted_at IS NULL
GROUP BY p.id;

```

---

## 7) RLS（行级安全）样例（按需启用）

> 后端需在会话设置：SET app.current_user_id = '<uuid>';
> 
> 
> 若要考虑屏蔽关系，请结合账号域的 `user_blocks`（在策略函数里判断）。
> 

```sql
-- 当前用户函数
CREATE OR REPLACE FUNCTION current_user_id() RETURNS UUID AS $$
  SELECT current_setting('app.current_user_id', true)::uuid
$$ LANGUAGE sql STABLE;

-- 示例：仅允许读取 public 或者作者本人（friends 策略可在有互关判断函数后追加）
ALTER TABLE posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY posts_public_read
  ON posts FOR SELECT
  USING (visibility = 'public' AND deleted_at IS NULL);

CREATE POLICY posts_self_read
  ON posts FOR SELECT
  USING (author_user_id = current_user_id() AND deleted_at IS NULL);

-- 写权限仅作者
CREATE POLICY posts_self_write
  ON posts FOR ALL
  USING (author_user_id = current_user_id());

-- 评论同理（最小示例：作者或所属帖可见）
ALTER TABLE comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY comments_public_read
  ON comments FOR SELECT
  USING (deleted_at IS NULL);  -- 若需与帖子可见性联动，可在此处调用自定义函数判断帖子可见性

CREATE POLICY comments_self_write
  ON comments FOR ALL
  USING (author_user_id = current_user_id());

```

> 互相关注可见（friends）与屏蔽过滤，可通过自定义函数 is_post_visible_to_user(post_id, viewer_id) 实现，并在 RLS USING 条件中调用。
> 

---

## 8) 话题沉淀与数据治理建议

- 定期任务：把 `posts.topics[]` 的高频词写入 `topics` 并补齐 `post_topics`；
- 字典话题改名合并时，同步修复 `post_topics`（保持历史一致）；
- 审核流：对 `post_reports/comment_reports` 建立处置 SLA 与只追加日志表；
- 反垃圾：在 `posts.meta`/`comments.meta` 中记录风控命中、风险分与屏蔽原因（不影响主查询）。

---

## 9) 最小自检（可直接运行）

```sql
-- 1) 取一个用户做作者
WITH u AS (
  SELECT id AS user_id FROM users ORDER BY created_at LIMIT 1
)
-- 2) 发一篇帖子
INSERT INTO posts (author_user_id, title, text, topics, visibility)
SELECT user_id, '第一次发帖', '今天带猫洗澡，超可爱！', ARRAY['猫','洗澡'], 'public' FROM u
RETURNING id INTO TEMP TABLE _p(pid);

-- 3) 建一个官方话题并关联
INSERT INTO topics (name, is_official) VALUES ('猫咪护理', TRUE)
ON CONFLICT DO NOTHING
RETURNING id INTO TEMP TABLE _t(tid);

INSERT INTO post_topics (post_id, topic_id)
SELECT pid, tid FROM _p CROSS JOIN _t
ON CONFLICT DO NOTHING;

-- 4) 评论两条（含一条楼中楼）
WITH c1 AS (
  INSERT INTO comments (post_id, author_user_id, text)
  SELECT pid, (SELECT user_id FROM u), '好可爱！！' FROM _p
  RETURNING id
)
INSERT INTO comments (post_id, author_user_id, parent_comment_id, text)
SELECT (SELECT pid FROM _p), (SELECT user_id FROM u), (SELECT id FROM c1), '楼中楼来啦';

-- 5) 点赞帖子与评论
INSERT INTO post_reactions (post_id, user_id)   SELECT pid, (SELECT user_id FROM u) FROM _p ON CONFLICT DO NOTHING;
INSERT INTO comment_reactions (comment_id, user_id)
SELECT id, (SELECT user_id FROM u) FROM comments ORDER BY created_at DESC LIMIT 1
ON CONFLICT DO NOTHING;

-- 6) 校验计数与视图
SELECT id, like_count, comment_count FROM posts WHERE id IN (SELECT pid FROM _p);
SELECT * FROM post_with_topics_v WHERE post_id IN (SELECT pid FROM _p);

```

---

### 备注：如坚持单表“反应/举报”（双外键 + CHECK）方案（可选替代）

```sql
-- 单表反应（仅示例，不与上面并存）
CREATE TABLE IF NOT EXISTS reactions (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id    UUID,
  comment_id UUID,
  user_id    UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  type       TEXT NOT NULL DEFAULT 'like',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  CHECK ((post_id IS NOT NULL AND comment_id IS NULL) OR (post_id IS NULL AND comment_id IS NOT NULL)),
  FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
  FOREIGN KEY (comment_id) REFERENCES comments(id) ON DELETE CASCADE
);

```