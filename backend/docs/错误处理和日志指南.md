# 错误处理和日志系统使用指南

## 目录
- [概述](#概述)
- [错误处理](#错误处理)
- [日志系统](#日志系统)
- [中间件](#中间件)
- [使用示例](#使用示例)
- [测试](#测试)

---

## 概述

本项目实现了完整的错误处理和日志系统，包括：
- 自定义错误类体系
- Winston 日志框架
- 请求追踪（Request ID）
- 性能监控
- 统一的错误响应格式

---

## 错误处理

### 错误类层次结构

所有自定义错误都继承自 `BaseError`：

```
BaseError (基础错误类)
├── ValidationError (400) - 数据验证错误
├── AuthError (401) - 认证错误
├── ForbiddenError (403) - 授权错误
├── NotFoundError (404) - 资源未找到
├── ConflictError (409) - 资源冲突
└── DatabaseError (500) - 数据库错误
```

### 使用错误类

#### 1. 基本用法

```javascript
import { ValidationError, NotFoundError } from './src/errors/index.js';

// 简单错误
throw new ValidationError('Email is required');

// 带详细信息的错误
throw new NotFoundError('User not found', {
  userId: '123',
  searchedIn: 'database',
});
```

#### 2. 在路由中使用

```javascript
import { asyncHandler } from './src/middleware/index.js';
import { ValidationError, NotFoundError } from './src/errors/index.js';

// 同步路由
app.get('/users/:id', (req, res, next) => {
  const user = findUserById(req.params.id);
  
  if (!user) {
    return next(new NotFoundError('User not found', { userId: req.params.id }));
  }
  
  res.json(user);
});

// 异步路由（推荐使用 asyncHandler）
app.post('/users', asyncHandler(async (req, res) => {
  const { email, username } = req.body;
  
  // 验证
  if (!email || !email.includes('@')) {
    throw new ValidationError('Invalid email format', {
      field: 'email',
      value: email,
    });
  }
  
  // 检查冲突
  const existingUser = await prisma.user.findUnique({ where: { email } });
  if (existingUser) {
    throw new ConflictError('Email already exists', {
      field: 'email',
      value: email,
    });
  }
  
  // 创建用户
  const user = await prisma.user.create({ data: { email, username } });
  res.status(201).json(user);
}));
```

### 错误响应格式

所有错误都会返回统一的 JSON 格式：

```json
{
  "error": {
    "name": "ValidationError",
    "message": "Invalid email format",
    "code": "VALIDATION_ERROR",
    "statusCode": 400,
    "details": {
      "field": "email",
      "value": "invalid-email"
    },
    "timestamp": "2025-10-31T10:30:00.000Z"
  }
}
```

### Prisma 错误自动处理

系统会自动处理常见的 Prisma 错误：

| Prisma 错误码 | HTTP 状态码 | 说明 |
|--------------|------------|------|
| P2002 | 409 | 唯一约束冲突 |
| P2025 | 404 | 记录未找到 |
| P2003 | 400 | 外键约束失败 |
| P2011 | 400 | 非空约束失败 |
| P2014 | 400 | 关系违规 |

---

## 日志系统

### 日志级别

系统支持以下日志级别（从高到低）：

1. **error** - 错误信息
2. **warn** - 警告信息
3. **info** - 一般信息
4. **http** - HTTP 请求
5. **debug** - 调试信息

开发环境显示所有级别（debug），生产环境只显示 info 及以上。

### 日志文件

日志自动写入以下文件：

- `logs/combined.log` - 所有日志
- `logs/error.log` - 仅错误日志
- `logs/exceptions.log` - 未捕获异常
- `logs/rejections.log` - 未处理的 Promise 拒绝

### 使用日志

#### 1. 在路由中使用

每个请求都有自己的 logger，自动包含 Request ID：

```javascript
app.get('/users', asyncHandler(async (req, res) => {
  req.logger.info('Fetching users list');
  
  const users = await prisma.user.findMany();
  
  req.logger.info(`Found ${users.length} users`);
  
  res.json(users);
}));
```

#### 2. 在服务层使用

```javascript
import logger from './src/config/logger.js';

export class UserService {
  async createUser(data) {
    logger.info('Creating new user', { email: data.email });
    
    try {
      const user = await prisma.user.create({ data });
      logger.info('User created successfully', { userId: user.id });
      return user;
    } catch (error) {
      logger.error('Failed to create user', { error: error.message });
      throw error;
    }
  }
}
```

#### 3. 不同级别的日志

```javascript
// 调试信息（仅开发环境）
req.logger.debug('User data:', { userData });

// 一般信息
req.logger.info('User logged in', { userId: user.id });

// 警告（需要注意但不是错误）
req.logger.warn('User attempted to access restricted resource', {
  userId: user.id,
  resource: req.path,
});

// 错误
req.logger.error('Database query failed', {
  error: error.message,
  query: 'SELECT * FROM users',
});
```

### 请求追踪

每个请求都有唯一的 Request ID，用于日志追踪：

```javascript
// 客户端可以在请求头中提供 Request ID
fetch('/api/users', {
  headers: {
    'X-Request-ID': 'custom-request-id',
  },
});

// 服务器会在响应头中返回 Request ID
// X-Request-ID: custom-request-id

// 所有该请求相关的日志都会包含这个 ID
```

### 性能监控

系统自动监控请求处理时间：

- 超过 **500ms** 的请求会记录 info 日志
- 超过 **1秒** 的请求会记录 warn 日志（慢请求）

```javascript
// 日志示例
{
  "message": "Slow request detected",
  "requestId": "abc-123",
  "method": "GET",
  "url": "/api/users",
  "statusCode": 200,
  "duration": "1523ms"
}
```

---

## 中间件

### 中间件执行顺序

```javascript
import express from 'express';
import {
  requestIdMiddleware,
  requestLogger,
  performanceLogger,
  errorHandler,
  notFoundHandler,
} from './src/middleware/index.js';

const app = express();

// 1. 基础中间件
app.use(express.json());
app.use(cors());

// 2. 日志和追踪中间件
app.use(requestIdMiddleware);   // 生成请求ID
app.use(performanceLogger);     // 性能监控
app.use(requestLogger);         // 请求日志

// 3. 业务路由
app.use('/api/users', userRoutes);
app.use('/api/posts', postRoutes);

// 4. 错误处理（必须放在最后）
app.use(notFoundHandler);       // 404 处理
app.use(errorHandler);          // 全局错误处理
```

### 中间件说明

#### requestIdMiddleware
为每个请求生成唯一ID，支持从请求头读取。

#### performanceLogger
监控请求处理时间，记录慢请求。

#### requestLogger
记录所有 HTTP 请求的详细信息：
- 自动过滤敏感字段（password, token, secret 等）
- 忽略健康检查路由（/health, /ping）

#### errorHandler
全局错误处理：
- 处理自定义错误
- 处理 Prisma 错误
- 处理未知错误
- 生产环境隐藏错误堆栈

#### notFoundHandler
处理 404 错误（路由不存在）。

#### asyncHandler
包装异步路由处理器，自动捕获错误：

```javascript
import { asyncHandler } from './src/middleware/index.js';

// 不使用 asyncHandler（不推荐）
app.get('/users', async (req, res, next) => {
  try {
    const users = await prisma.user.findMany();
    res.json(users);
  } catch (error) {
    next(error);
  }
});

// 使用 asyncHandler（推荐）
app.get('/users', asyncHandler(async (req, res) => {
  const users = await prisma.user.findMany();
  res.json(users);
}));
```

---

## 使用示例

### 完整的 CRUD 示例

```javascript
import express from 'express';
import { asyncHandler } from '../middleware/index.js';
import {
  ValidationError,
  NotFoundError,
  ConflictError,
} from '../errors/index.js';
import { PrismaClient } from '@prisma/client';

const router = express.Router();
const prisma = new PrismaClient();

// 列表查询
router.get('/', asyncHandler(async (req, res) => {
  req.logger.info('Fetching users');
  
  const users = await prisma.user.findMany();
  
  res.json({
    data: users,
    count: users.length,
  });
}));

// 单个查询
router.get('/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;
  
  req.logger.info('Fetching user', { userId: id });
  
  const user = await prisma.user.findUnique({
    where: { id: parseInt(id) },
  });
  
  if (!user) {
    throw new NotFoundError('User not found', { userId: id });
  }
  
  res.json(user);
}));

// 创建
router.post('/', asyncHandler(async (req, res) => {
  const { email, username, password } = req.body;
  
  // 验证
  if (!email || !email.includes('@')) {
    throw new ValidationError('Invalid email format', {
      field: 'email',
      value: email,
    });
  }
  
  if (!username || username.length < 3) {
    throw new ValidationError('Username must be at least 3 characters', {
      field: 'username',
      minLength: 3,
    });
  }
  
  // 检查重复
  const existing = await prisma.user.findFirst({
    where: {
      OR: [
        { email },
        { username },
      ],
    },
  });
  
  if (existing) {
    const field = existing.email === email ? 'email' : 'username';
    throw new ConflictError(`${field} already exists`, {
      field,
      value: field === 'email' ? email : username,
    });
  }
  
  req.logger.info('Creating user', { email, username });
  
  // 创建用户
  const user = await prisma.user.create({
    data: { email, username, password },
  });
  
  req.logger.info('User created', { userId: user.id });
  
  res.status(201).json(user);
}));

// 更新
router.put('/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { username } = req.body;
  
  req.logger.info('Updating user', { userId: id });
  
  // Prisma 会自动抛出 P2025 错误（记录未找到）
  // 系统会自动转换为 404 响应
  const user = await prisma.user.update({
    where: { id: parseInt(id) },
    data: { username },
  });
  
  req.logger.info('User updated', { userId: id });
  
  res.json(user);
}));

// 删除
router.delete('/:id', asyncHandler(async (req, res) => {
  const { id } = req.params;
  
  req.logger.info('Deleting user', { userId: id });
  
  await prisma.user.delete({
    where: { id: parseInt(id) },
  });
  
  req.logger.info('User deleted', { userId: id });
  
  res.status(204).send();
}));

export default router;
```

---

## 测试

### 运行测试服务器

项目包含完整的测试文件 `test-error-logging.js`：

```bash
# 安装依赖
npm install

# 运行测试服务器
node test-error-logging.js
```

测试服务器会在 `http://localhost:3001` 启动。

### 可用测试端点

#### 1. 成功请求
```bash
curl http://localhost:3001/test/success
```

#### 2. 验证错误 (400)
```bash
curl -X POST http://localhost:3001/test/validation-error \
  -H "Content-Type: application/json" \
  -d '{"email":"invalid"}'
```

#### 3. 认证错误 (401)
```bash
curl http://localhost:3001/test/auth-error
```

#### 4. 授权错误 (403)
```bash
curl http://localhost:3001/test/forbidden-error
```

#### 5. 未找到错误 (404)
```bash
curl http://localhost:3001/test/not-found-error?id=999
```

#### 6. 冲突错误 (409)
```bash
curl -X POST http://localhost:3001/test/conflict-error \
  -H "Content-Type: application/json" \
  -d '{"username":"existing_user"}'
```

#### 7. 数据库错误 (500)
```bash
curl http://localhost:3001/test/database-error
```

#### 8. 未知错误 (500)
```bash
curl http://localhost:3001/test/unknown-error
```

#### 9. 异步错误处理
```bash
curl http://localhost:3001/test/async-error
```

#### 10. 慢请求测试
```bash
curl http://localhost:3001/test/slow-request
```

#### 11. Prisma 唯一约束错误
```bash
curl -X POST http://localhost:3001/test/prisma-p2002 \
  -H "Content-Type: application/json" \
  -d '{}'
```

#### 12. Prisma 未找到错误
```bash
curl http://localhost:3001/test/prisma-p2025
```

#### 13. 日志级别测试
```bash
curl http://localhost:3001/test/log-levels
```

#### 14. 敏感数据过滤测试
```bash
curl -X POST http://localhost:3001/test/sensitive-data \
  -H "Content-Type: application/json" \
  -d '{"username":"user1","password":"secret123","token":"abc"}'
```

### 测试请求追踪

```bash
# 提供自定义 Request ID
curl -H "X-Request-ID: my-custom-id-123" \
  http://localhost:3001/test/success

# 查看响应头中的 Request ID
curl -i http://localhost:3001/test/success
```

### 查看日志

测试时会生成日志文件：

```bash
# 查看所有日志
cat logs/combined.log

# 查看错误日志
cat logs/error.log

# 实时查看日志
tail -f logs/combined.log
```

---

## 最佳实践

### 1. 使用合适的错误类型

```javascript
// ✅ 正确
throw new ValidationError('Email is required');
throw new NotFoundError('User not found');

// ❌ 错误
throw new Error('Email is required');  // 不会有正确的状态码
```

### 2. 提供详细的错误信息

```javascript
// ✅ 正确 - 提供上下文信息
throw new ValidationError('Invalid age', {
  field: 'age',
  value: -5,
  min: 0,
  max: 150,
});

// ❌ 一般 - 缺少上下文
throw new ValidationError('Invalid age');
```

### 3. 在异步函数中使用 asyncHandler

```javascript
// ✅ 正确
app.get('/users', asyncHandler(async (req, res) => {
  const users = await prisma.user.findMany();
  res.json(users);
}));

// ❌ 错误 - 错误不会被捕获
app.get('/users', async (req, res) => {
  const users = await prisma.user.findMany();
  res.json(users);
});
```

### 4. 记录有意义的日志

```javascript
// ✅ 正确 - 包含上下文
req.logger.info('User login attempt', {
  userId: user.id,
  ip: req.ip,
  userAgent: req.get('user-agent'),
});

// ❌ 一般 - 缺少上下文
req.logger.info('User login');
```

### 5. 不要在日志中记录敏感信息

```javascript
// ✅ 正确
req.logger.info('User created', {
  userId: user.id,
  email: user.email,
});

// ❌ 错误 - 记录了密码
req.logger.info('User created', {
  userId: user.id,
  email: user.email,
  password: user.password,  // 不要这样做！
});
```

### 6. 使用环境变量控制日志级别

```bash
# 开发环境 - 显示所有日志
NODE_ENV=development npm start

# 生产环境 - 只显示重要日志
NODE_ENV=production npm start
```

---

## 故障排查

### 日志文件未创建

确保 `logs/` 目录存在：

```bash
mkdir -p logs
```

### 日志没有显示在控制台

检查 `NODE_ENV` 环境变量：

```bash
# 开发环境会显示控制台日志
echo $NODE_ENV

# 如果为空或不是 development，设置它
export NODE_ENV=development
```

### 错误没有被捕获

确保：
1. 使用了 `asyncHandler` 包装异步路由
2. 错误处理中间件在所有路由之后
3. 使用 `next(error)` 传递错误

```javascript
// 正确的顺序
app.use('/api/users', userRoutes);
app.use(notFoundHandler);
app.use(errorHandler);
```

---

## 环境配置

在 `.env` 文件中配置：

```env
# 应用配置
NODE_ENV=development
PORT=3000

# 日志配置
LOG_LEVEL=debug  # debug, info, warn, error
```

---

## 总结

本错误处理和日志系统提供了：

- ✅ 统一的错误响应格式
- ✅ 自动的 Prisma 错误处理
- ✅ 请求追踪（Request ID）
- ✅ 性能监控
- ✅ 敏感信息过滤
- ✅ 结构化日志
- ✅ 开发/生产环境支持
- ✅ 完整的测试覆盖

使用这些工具可以帮助你快速定位和解决问题，提高应用的可维护性和可观测性。

